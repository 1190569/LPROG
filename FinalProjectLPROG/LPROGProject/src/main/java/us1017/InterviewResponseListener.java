package us1017;

import us1017.grammar.InterviewResponsesBaseListener;
import us1017.grammar.InterviewResponsesParser;

/**
 * Listener class for handling events during the parsing of interview responses.
 * It extends the base listener generated by ANTLR.
 */
public class InterviewResponseListener extends InterviewResponsesBaseListener {
    public boolean errormsg = false;

    /**
     * Called when entering a QuestionResponse node in the parse tree.
     * Validates the answer type and checks for errors.
     *
     * @param ctx The parse tree context for the question response.
     */
    @Override
    public void enterQuestionResponse(InterviewResponsesParser.QuestionResponseContext ctx) {
        String question = ctx.STRING().getText().replace("\"", "");
        String answer = ctx.response().getText().replace("\"", "");
        String expectedType = ctx.questionType().getText();

        System.out.println("Checking response for question: " + question);
        System.out.println("Type of question: " + expectedType);

        if (!validateAnswerType(answer, expectedType)) {
            String detectedType = detectType(answer);
            String error = generateErrorMessage(question, expectedType, detectedType);
            System.err.println(error);
            errormsg = true;
        } else {
            System.out.println("Answer: " + answer);
            System.out.println("Answertype: " + detectType(answer));
        }

        System.out.println();
    }

    /**
     * Called when entering the Plugin node in the parse tree.
     * Logs the start of the checking process.
     *
     * @param ctx The parse tree context for the plugin.
     */
    @Override
    public void enterPlugin(InterviewResponsesParser.PluginContext ctx) {
        System.out.println("\nStart Checking \n");
    }

    /**
     * Called when exiting the Plugin node in the parse tree.
     * Logs the end of the checking process.
     *
     * @param ctx The parse tree context for the plugin.
     */
    @Override
    public void exitPlugin(InterviewResponsesParser.PluginContext ctx) {
        System.out.println("Checking finished.\n");
    }

    /**
     * Validates the answer type against the expected type.
     *
     * @param answer The answer to validate.
     * @param type The expected type of the answer.
     * @return true if the answer matches the expected type, false otherwise.
     */
    private boolean validateAnswerType(String answer, String type) {
        return switch (type) {
            case "NumericScale" -> answer.matches("\\d/10"); // Example 5/10
            case "IntegerNumber" -> answer.matches("\\d+"); // Example 45666
            case "Date" -> answer.matches("\\d{4}-\\d{2}-\\d{2}"); // Example 2002/04/02
            case "Time" -> answer.matches("\\d{2}:\\d{2}"); // Example 18:59
            case "DecimalNumber" -> answer.matches("\\d+\\.\\d+"); // Example 45.533
            case "TrueFalse" -> answer.equals("True") || answer.equals("False"); // Example: True
            case "SingleChoice", "MultipleChoice" ->
                // Check if the response contains "1.", "2.", "3.", "4.", and "5."
                    answer.matches(".*(1\\.|2\\.|3\\.|4\\.|5\\.).*"); // Example: either x. or x. and y. ...
            case "ShortTextAnswer" -> true;  // Every text is okay
            default -> false;
        };
    }

    /**
     * Detects the type of the given answer.
     *
     * @param answer The answer to detect the type of.
     * @return The detected type of the answer as a string.
     */
    private String detectType(String answer) {
        if (answer.matches("\\d/10")) { // see examples at validateanser
            return "NumericScale";
        } else if (answer.matches("\\d+")) {
            return "an integer number";
        } else if (answer.matches("\\d+\\.\\d+")) {
            return "a decimal number";
        } else if (answer.matches("\\d{4}-\\d{2}-\\d{2}")) {
            return "a date (YYYY-MM-DD)";
        } else if (answer.matches("\\d{2}:\\d{2}")) {
            return "a time (HH:MM)";
        } else if (answer.equals("True") || answer.equals("False")) {
            return "a boolean ('True' or 'False')";
        } else if (answer.matches(".*(1\\.|2\\.|3\\.|4\\.|5\\.).*")){
                return "a single/ multiple choice";
        } else {
            return "text";
        }
    }

    /**
     * Generates an error message for a question with an invalid answer type.
     *
     * @param question The question being answered.
     * @param expectedType The expected type of the answer.
     * @param detectedType The detected type of the answer.
     * @return The generated error message.
     */
    private String generateErrorMessage(String question, String expectedType, String detectedType) {
        return "Error at question " + question + ": expected " + expectedType + ", but got " + detectedType;
    }
}
